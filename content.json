{"meta":{"title":"Welcome to TonyYang's Blog","subtitle":"ChuiGe","description":"we have anything you want","author":"TonyYang","url":"http://YangHQ666.com"},"pages":[{"title":"","date":"2017-10-07T10:40:53.000Z","updated":"2017-10-07T10:40:53.000Z","comments":true,"path":"about/index.html","permalink":"http://YangHQ666.com/about/index.html","excerpt":"","text":"关于作者一名硬件和软件都搞的老gay且非常热爱音乐的死肥宅（其实我是喜欢运动的 : ) 目前正在上学，每次考试差点挂科。 热爱搞 音乐`` 撸琴 小技术 。 我在哪里？湖北：WuHan。(欢迎各位过来搞) 关于学习软件硬件都搞，喜欢看看小动物百科，研究研究乐理。近期学习：《如何做到Dota补刀一刀不漏》 《如何在期末考试时转运》 座右铭 不要去想未来，先走好每一步。 喜欢的明星和乐队乐队：AC／DC 和kiss明星： slash和bukethead歌手：li rong hao（偷笑）"}],"posts":[{"title":"CALayer(上)","slug":"CALayer-上","date":"2017-11-19T08:04:19.000Z","updated":"2017-11-19T13:29:29.000Z","comments":true,"path":"2017/11/19/CALayer-上/","link":"","permalink":"http://YangHQ666.com/2017/11/19/CALayer-上/","excerpt":"","text":"CALayer 原本想把CALayer作为一个小知识来写的，但发现其中有很多”骚“操作，没办法。。。。 概念CALayer（这里简单地称其为层）。首先要说的是CALayers 是屏幕上的一个具有可见内容的矩形区域，每个UIView都有一个根CALayer， 其所有的绘制（视觉效果）都是在这个layer上进行的。 当我们设置layer属性时候其实就是在设定CALayer，UIView所有你能看到的显示的内容，后面都有一个Layer。 CALayer是为更好实现View的动画，比如你想View消失时做成玻璃破碎的效果，就可以在View的CALayer上密密麻麻排一层N个小的子CALayer，设置每个CALayer的落下动画，用View就比较不合适。 使用你可以直接使用CALayer，也可以使用其子类，如CAGradientLayer，CATextLayer， CAShapeLayer等等。 基本设置如下： 12345678910CALayer *sublayer = [CALayer layer];sublayer.backgroundColor = [UIColor blueColor].CGColor;sublayer.shadowOffset = CGSizeMake(15, 15);//阴影偏移量sublayer.shadowRadius = 5.0;//设置圆角sublayer.shadowOpacity = 0.8; //设置透明度sublayer.shadowColor = [UIColor blackColor].CGColor;sublayer.frame = CGRectMake(30, 30, 128,193);sublayer.anchorPoint = CGPointMake(0.1 , 0.1); //设置在view上的坐标sublayer.contents = (id)[UIImage imageNamed:@&quot;qie.png&quot;].CGImage; //给layer设置背景图片[self.view.layer addSublayer:sublayer]; 效果图： CALayer的子类CAShapeLayerCAShapeLayer比CALayer多出的属性： Path: CAShapeLayer的path属性是他如此牛逼的一个重要起点，也是它和贝塞尔曲线紧密连接一个入口，他决定了我们要在图层上画一个什么形状。（注：当与贝塞尔曲线一起使用的时候，生成的曲线的位置是相对于生成的layer的，所以当你利用贝塞尔曲线设置了path后，再设置layer的position和bounds你会感觉很奇怪，最简单的方式就是单纯利用贝塞尔曲线决定图层的位置和大小）.推荐一篇讲贝塞尔曲线用法的博客 fillColor和fillRule：fillColor即layer的path的填充颜色，fillRule属性用于指定使用哪一种算法去判断画布上的某区域是否属于该图形“内部” （内部区域将被填充）。对一个简单的无交叉的路径，哪块区域是“内部” 是很直观清除的。但是，对一个复杂的路径，比如自相交或者一个子路径包围另一个子路径，“内部”的理解就不那么明了。fillRule提供两种选项用于指定如何判断图形的内部”kCAFillRuleNonZero,kCAFillRuleEvenOdd： kCAFillRuleNonZero 字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部。下图演示了kCAFillRuleNonZero规则 : kCAFillRuleEvenOdd 字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。下图演示了kCAFillRuleEvenOdd 规则： 使用UIBezierPath（贝塞尔曲线）的基本方法： 创建方法： 123456789101112131415161718//创建方法//画矩形+ (instancetype)bezierPathWithRect:(CGRect)rect;//根据矩形画内切曲线,通常用于画圆或则椭圆+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;//画带圆角的矩形+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius;//可以指定矩形的某角为圆角+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;//画圆弧(center: 中心点坐标 radius: 半径 startAngle: 弧线开始角度值 endAngle: 弧线结束角度值 clockwise: 是否顺时针画弧线)+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;//使用CGPath生成贝塞尔曲线+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath; 画图方法： 12345678910111213141516171819202122232425//画图方法：//移动起点- (void)moveToPoint:(CGPoint)point;//画直线- (void)addLineToPoint:(CGPoint)point;//画三次贝塞尔曲线,两个控制点.- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2;//画二次贝塞尔曲线,一个控制点.- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;//画圆弧- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0);//闭合线- (void)closePath;//用于在- (void)drawRect:(CGRect)rect中调用//填充- (void)fill;//连线- (void)stroke; 设置strokeStart和strokeEnd 123456789101112131415UIBezierPath *bezerpath = [UIBezierPath bezierPathWithRect:CGRectMake(30, 50, 100, 100)];bezerpath.lineWidth = 10;CAShapeLayer *shapeLayer1 = [CAShapeLayer layer];shapeLayer1.path = bezerpath.CGPath;shapeLayer1.fillColor = [UIColor redColor].CGColor;shapeLayer1.strokeColor = [UIColor blackColor].CGColor;shapeLayer1.lineWidth = 10;//设置外围线的粗细shapeLayer1.strokeStart = 0.3;//设置划线外围的起始位置shapeLayer1.strokeEnd = 0.7;//设置划线外围的终止位置[self.view.layer addSublayer:shapeLayer1];// 效果如图： 虚线设置（lineDashPattern） 虚线设置，为一个数组，数组中奇数位实线长度，偶数位带遍空白长度（注意：这里的奇数，偶数以数组的第一个元素索引为1计算），具体小demo： 1234567891011121314151617181920212223242526272829303132333435363738-(void)drawThePaint&#123;CAShapeLayer *dashshape = [CAShapeLayer layer];UIBezierPath *dashPath = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 0, 200, 100) cornerRadius:20/*设置方形的角度*/];dashshape.path = dashPath.CGPath;dashshape.position = CGPointMake(100, 100);dashshape.fillColor = [UIColor clearColor].CGColor;dashshape.strokeColor = [UIColor whiteColor].CGColor;dashshape.lineWidth = 3.0;//虚线设置，为一个数组，数组中奇数位实线长度，偶数位带遍空白长度（注意：这里的奇数，偶数以数组的第一个元素索引为1计算）dashshape.lineDashPattern = @[@(6),@(6)];dashshape.strokeStart = 0;dashshape.strokeEnd = 1;dashshape.zPosition = 999;[self.view.layer addSublayer:dashshape];NSTimeInterval delatime = 0.3f;//定时器间隔时间NSTimeInterval timeInterval = 0.1f;//创建子线程队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//使用之前创建的队列来创建计时器_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);//设置延时执行时间，delayTime为要延时的秒数dispatch_time_t starDelayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)delatime);//设置计时器dispatch_source_set_timer(_timer, starDelayTime, timeInterval * NSEC_PER_SEC, 0.1 * NSEC_PER_SEC);dispatch_source_set_event_handler(_timer, ^&#123;//执行事件dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;CGFloat _add = 3;dashshape.lineDashPhase -=_add;&#125;);&#125;);// 启动计时器dispatch_resume(_timer);&#125; 实现效果：(虚线是运动的) 用贝塞尔曲线画一个圆形和三角形： 12345678910111213141516171819202122232425262728293031323334353637383940414243-(void)checkFillRule&#123;//画三角形UIBezierPath *path = [UIBezierPath bezierPath];[path moveToPoint:CGPointMake(20, 20)];//移动起点[path addLineToPoint:CGPointMake(self.view.frame.size.width -40, 20)];//画直线[path addLineToPoint:CGPointMake(self.view.frame.size.width /2, self.view.frame.size.height -20)];// 最后的闭合线是可以通过调用closePath方法来自动生成的，也可以调用-addLineToPoint:方法来添加[path closePath];// 设置线宽path.lineWidth = 1.5;// 设置填充颜色UIColor *fillcolor = [UIColor grayColor];[fillcolor set];[path fill];// 设置画笔颜色UIColor *strokeColor = [UIColor blueColor];[strokeColor set];// 根据我们设置的各个点连线[path stroke];//----------------------------------------------------------//画圆形：UIBezierPath *path3 = [[UIBezierPath alloc]init];CGPoint circleCenter = self.view.center;[path3 moveToPoint:CGPointMake(circleCenter.x + 50, circleCenter.y)];[path3 addArcWithCenter:circleCenter radius:50 startAngle:0 endAngle:2*M_PI clockwise:YES];//-------------------------------------------------------------//创建一个shapeLayer，并设置各种属性CAShapeLayer *shapeLayer = [CAShapeLayer layer];shapeLayer.strokeColor = [UIColor redColor].CGColor;shapeLayer.fillColor = [UIColor greenColor].CGColor;shapeLayer.fillRule = kCAFillRuleEvenOdd;shapeLayer.lineWidth = 5;shapeLayer.lineJoin = kCALineJoinBevel;//将shapeLayer的path设置成自定义的pathshapeLayer.path = path.CGPath; //这里是三角形的，如果是圆就换成path3//将这个shapeLayer添加到view的Layer层[self.view.layer addSublayer:shapeLayer];&#125; 运行结果： CAGradientLayer 用途：一般生成平滑的颜色过滤 特有属性colors在Layer中现实的几种颜色并完成完美过渡，和CAShapeLayer的path一样，colors是CAGradientLayer特殊属性的起点，也就是x 显示的要素。 locations颜色区间分布比例，默认为线性均匀分布。取值范围为0～1递增，一般来说其中的元素个数应与colors中的元素个数相同，不同时系统会自行处理分布规则。demo： 12345678910111213-(void)drawcolor&#123;CAGradientLayer *gLayer = [CAGradientLayer layer];gLayer.frame = CGRectMake(80, 180, 200, 200);gLayer.locations = @[@(0.5),@(0.5)]; //颜色区间分布比例，默认为线性均匀分布。取值范围为0～1递增，一般来说其中的元素个数应与colors中的元素个数相同，不同时系统会自行处理分布规则。gLayer.colors = @[(__bridge id)[UIColor redColor].CGColor,(__bridge id)[UIColor greenColor].CGColor];gLayer.locations = @[@(0.3),@(0.7)];gLayer.startPoint = CGPointMake(0, 0);gLayer.endPoint = CGPointMake(1, 1);//startPoint决定了变色范围的起始点，endPoint决定了变色范围的结束点，两者的连线决定变色的趋势：[self.view.layer addSublayer:gLayer];&#125; 运行效果: CATransformLayerCATransform3D定义了一个4x4的CGFloat值的矩阵：（主要功能已标出） 1234567891011struct CATransform3D&#123;CGFloat m11（x缩放）, m12（y切变）, m13（旋转）, m14;CGFloat m21（x切变）, m22（y缩放）, m23, m24;CGFloat m31（旋转）, m32, m33, m34（透视效果，要操作的对象要有旋转的角度，不然没效果）;CGFloat m41（平移）, m42（y平移）, m43（z移动）, m44;&#125;m34：m34透视效果，一般通过-1.0/d来应用透视效果，d代表想象中视觉相机与屏幕之间的距离，以像素为单位，通常d = 500-1000就已经很好了，一般是用于构造一个3D结构，一般是这样设置：CATransform3D fromValue = CATransform3DIdentity;fromValue.m34 = 1.0 / -500;CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloattz)//tx:X轴偏移的位置，往下为正数；ty：Y轴偏移的位置，往右为正数；tz：z轴偏移的位置，往外为正数 用法举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243CALayer *layer = [CALayer layer];layer.bounds = CGRectMake(0, 0, 100, 100);layer.position = CGPointMake(self.view.center.x, 200);layer.opacity = 0.6;layer.backgroundColor = [UIColor redColor].CGColor;layer.borderColor = [[UIColor greenColor]colorWithAlphaComponent:0.4].CGColor;layer.borderWidth = 5.0;layer.cornerRadius = 20;layer.masksToBounds = YES;CALayer *layer2 = [CALayer layer];layer2.bounds = CGRectMake(0, 0, 100, 100);// layer2.position = CGPointMake(self.view.center.x, 400);layer2.opacity = 0.6;//不透明度layer2.backgroundColor = [UIColor blackColor].CGColor;layer2.borderColor = [UIColor grayColor].CGColor;layer2.borderWidth = 5.0;layer2.cornerRadius = 10;layer2.masksToBounds = YES;CATransformLayer *containLayer = [CATransformLayer layer];containLayer.bounds = CGRectMake(0, 0, 100, 100);containLayer.position = self.view.center;[containLayer addSublayer:layer];[containLayer addSublayer:layer2];[self.view.layer addSublayer:containLayer];//旋转设置CATransform3D containfrom = CATransform3DIdentity;containfrom.m34 = -1.0 / 500;containLayer.transform = containfrom;//旋转设置CATransform3D fromValue = CATransform3DIdentity;fromValue = CATransform3DRotate(fromValue, M_PI_4, 0, 1, 0);fromValue = CATransform3DTranslate(fromValue, 0, 0, -10);layer.transform = fromValue;//旋转设置CATransform3D fromValue2 = CATransform3DIdentity;fromValue2 = CATransform3DRotate(fromValue2, M_PI_2, 0, 1, 0);fromValue2 = CATransform3DTranslate(fromValue2, 0, 0, -50);layer2.transform = fromValue2; 运行结果： 最后送上一个立方体的小demo，CALayer还有一些子类，后面会一一介绍的：） 声明：声明：本文非原创，仅仅整理一些开发技能知识文章，以作存档学习用做参考。 参考文章：http://www.jianshu.com/p/2ad0e265bc50 ​ http://www.jianshu.com/p/98ff8012362a ​ http://www.jianshu.com/p/999ad5ae6edf","categories":[{"name":"UI设计","slug":"UI设计","permalink":"http://YangHQ666.com/categories/UI设计/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://YangHQ666.com/tags/iOS开发/"},{"name":"UI设计","slug":"UI设计","permalink":"http://YangHQ666.com/tags/UI设计/"},{"name":"CALayer","slug":"CALayer","permalink":"http://YangHQ666.com/tags/CALayer/"}]},{"title":"iOS多线程之GCD","slug":"iOS多线程之GCD","date":"2017-11-10T15:14:01.000Z","updated":"2017-11-10T15:22:22.000Z","comments":true,"path":"2017/11/10/iOS多线程之GCD/","link":"","permalink":"http://YangHQ666.com/2017/11/10/iOS多线程之GCD/","excerpt":"","text":"iOS多线程之GCD 在此之前先了解一下什么是线程，进程，锁，以及[Runloop] 线程与进程：http://www.jianshu.com/p/95aa5446361d 锁：http://www.jianshu.com/p/1e59f0970bf5 Runloop：http://www.jianshu.com/p/d260d18dd551 GCD中的几个概念 12345678910111213141516171819//全局队列，一个并行的队列dispatch_get_global_queue//主队列，主线程中的唯一队列，一个串行队列dispatch_get_main_queue自定义队列//串行队列dispatch_queue_create(&quot;serialqueue&quot;, DISPATCH_QUEUE_SERIAL)//并行队列dispatch_queue_create(&quot;concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT)同步异步线程创建//同步dispatch_sync(..., ^(block))//异步dispatch_async(..., ^(block))作者：kscorpio链接：http://www.jianshu.com/p/6f6e995c3f7a來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 队列和线程的区别简单来说，队列就是用来存放任务的“暂存区”，而线程是执行任务的路径，GCD将这些存在于队列的任务取出来放到相应的线程上去执行，而队列的性质决定了在其中的任务在哪种线程上执行 串行加异步1234567891011121314151617181920int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;dispatch_queue_t queue = dispatch_queue_create(&quot;serial.queue&quot;, DISPATCH_QUEUE_SERIAL);//异步执行不会阻塞队列NSLog(@&quot;Begin ----- %@&quot;,[NSThread currentThread]);//先执行Begin后马上执行Enddispatch_async(queue, ^&#123;NSLog(@&quot;Task ---1&quot;);&#125;);//异步执行+串行队列可以开启一个新的线程，所以Task 1线程是2dispatch_async(queue, ^&#123;NSLog(@&quot;Task --- 2&quot;);&#125;);//异步执行+串行，所以Task 2仍在线程2内（排在Task 1后面）NSLog(@&quot;End -----%@&quot;,[NSThread currentThread]);NSLog(@&quot;Hello, World!&quot;);&#125;return 0;&#125; 输出 过程如图所示：（串行的异步操作只会创建一个新线程） 并行加异步123456789101112131415161718192021222324252627NSLog(@&quot;asyncConcurrent -- begin&quot;);dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;,DISPATCH_QUEUE_CONCURRENT);//并行队列//创建异步执行dispatch_async(queue, ^&#123;for (int i = 0; i&lt;2; ++i) &#123;NSLog(@&quot;1--------%@&quot;,[NSThread currentThread]);&#125;&#125;);dispatch_async(queue, ^&#123;for (int i = 0; i&lt;2; ++i) &#123;NSLog(@&quot;2--------%@&quot;,[NSThread currentThread]);&#125;&#125;);dispatch_async(queue, ^&#123;for (int i = 0; i&lt;2; ++i) &#123;NSLog(@&quot;3--------%@&quot;,[NSThread currentThread]);&#125;&#125;);NSLog(@&quot;end&quot;);&#125;/*1.并行队列加异步执行，创建了3个线程，三个任务都是同时执行，不分先后2.函数在执行时候，先执行的是begin和end这两句话。*/ 运行结果： 串行加同步正常情况下： 1234567891011121314151617int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;dispatch_queue_t queue = dispatch_queue_create(&quot;标识符&quot;,DISPATCH_QUEUE_SERIAL);//串行队列NSLog(@&quot;Begin ----- %@&quot;,[NSThread currentThread]);dispatch_sync(queue, ^&#123;NSLog(@&quot;Task 1&quot;);&#125;);//同步执行dispatch_sync(queue, ^&#123;NSLog(@&quot;Task 2&quot;);&#125;);//同步执行NSLog(@&quot;End ----- %@&quot;,[NSThread currentThread]);NSLog(@&quot;Hello, World!&quot;);&#125;return 0;&#125; 输出： 进程死锁情况： 12345678910111213141516171819202122int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;dispatch_queue_t s_queue = dispatch_queue_create(&quot;标识符&quot;,DISPATCH_QUEUE_SERIAL);//串形队列NSLog(@&quot;Begin ---- %@&quot;,[NSThread currentThread]); //外部任务dispatch_async(s_queue, ^&#123;NSLog(@&quot;Begin 2---%@&quot;,[NSThread currentThread]);dispatch_sync(s_queue, ^&#123;NSLog(@&quot;Task 1---%@&quot;,[NSThread currentThread]);//同步执行的内部任务&#125;);//当 外部任务 和 同步执行的内部任务 处于一个 串行队列 时会导致死锁dispatch_sync(s_queue, ^&#123;NSLog(@&quot;Task 2--- %@&quot;,[NSThread currentThread]);&#125;);NSLog(@&quot;End 2 ------%@&quot;,[NSThread currentThread]);&#125;);NSLog(@&quot;End --------%@&quot;,[NSThread currentThread]);NSLog(@&quot;Hello, World!&quot;);&#125;return 0;&#125;// 当 外部任务 和 同步执行的内部任务 处于一个 串行队列 时会导致死锁 死锁示意图： 输出： 并行加同步12345678910111213dispatch_queue_t queue = dispatch_queue_create(&quot;并行加同步&quot;,DISPATCH_QUEUE_CONCURRENT);NSLog(@&quot;Begin ----- %@&quot;,[NSThread currentThread]);dispatch_sync(queue, ^&#123;NSLog(@&quot;Task 1 ------ %@&quot;,[NSThread currentThread]);&#125;);dispatch_sync(queue, ^&#123;NSLog(@&quot;Task 2 ----%@&quot;,[NSThread currentThread]);&#125;);NSLog((@&quot;End ------ %@&quot;), [NSThread currentThread]);NSLog(@&quot;Hello, World!&quot;);&#125;return 0;&#125; 运行结果： 最后总结一下： 声明：本文非原创，仅仅整理一些开发技能知识文章，以作存档学习用参考。参考文章：http://www.jianshu.com/p/6f6e995c3f7a","categories":[{"name":"iOS多线程","slug":"iOS多线程","permalink":"http://YangHQ666.com/categories/iOS多线程/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://YangHQ666.com/tags/iOS开发/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://YangHQ666.com/tags/Objective-C/"},{"name":"iOS多线程","slug":"iOS多线程","permalink":"http://YangHQ666.com/tags/iOS多线程/"}]},{"title":"内存管理","slug":"C语言之内存管理","date":"2017-11-02T14:28:51.000Z","updated":"2017-11-03T08:57:20.000Z","comments":true,"path":"2017/11/02/C语言之内存管理/","link":"","permalink":"http://YangHQ666.com/2017/11/02/C语言之内存管理/","excerpt":"","text":"C语言之内存管理 有效的分配内存资源是程序设计中首要考虑的问题，由于之前对内存管理方面了解的不是很多，现在深入了解一下 内存中的五大区域先上一幅图： 栈：又称为堆栈，存放程序临时创建的局部变量，当局部变量的作用域被执行完毕之后，这个局部变量就会被系统立即回收。除此以外函数被调用时候，参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中，由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。注意：栈空间是向下增长的，每个线程有一个自己的栈，在linux上默认的大小是8M，可以用ulimit查看和修改。 堆：用于存放进程运行被动态分配的内存段（即调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上；当利用free等函数释放内存时，被释放的内存从堆中被剔除） BBS段：通常是指用来存放程序中未初始化的 全局变量和静态变量（static）的一块内存区域，BBS的全称是Block Started by Symbol的简称BSS段属于静态内存分配。 BSS节不包含任何数据，只是简单的维护开始和结束的地址，即总大小，以便内存区能在运行时分配并被有效地清零，也就是说：全局变量和静态变量一旦初始化后就回收，并转存到数据段中。例如： 12345int YH[30000]; //存放在bss段void main()&#123;&#125;------------------------------------------------------------int YH[30000]=&#123;1,2,3,4,5&#125;; //存放在data段 (已经初始化了)void main()&#123;&#125; ​​​ 数据段：通常是指用来存放程序中已初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配，可以分为只读数据段和读写数据段。 字符串常量等，但一般都是放在只读数据段中。 ​​​ 代码段：通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等，但一般都是放在只读数据段中。 比如： ​​12​int a = 0; //拆分成int a和a = 0，int a在编译时就执行了，并没有放在代码段而只有a = 0这句放在了代码段​ ​​### 代码实践​​这里先推荐一篇文章，里面的例子讲的都挺经典的http://www.cnblogs.com/yif1991/p/5049638.html​​123456789101112131415​const int all = 4;//all为静态变量并且初始化了，放在数据段​​int main()&#123;​char *b = NULL;//main函数中的&quot;char *b = NULL&quot;定义了自动变量b，故其存放在栈区​​int c = 10;//c为局部变量，放在栈中​​b = (char*)malloc(1024*sizeof(char));//b申请部分内存空间，放在堆中​​free(b);​​printf(&quot;c = %d a = %d&quot;,c,all);​​&#125;​ OC内存管理 由于移动设备的内存极其有限，所以每个APP所占的内存也是有限制的，当app所占用的内存较多时，系统就会发出内存警告，这时需要回收一些不需要再继续使用的内存空间，比如回收一些不再使用的对象和变量等。 基本原理​​","categories":[{"name":"C语言","slug":"C语言","permalink":"http://YangHQ666.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://YangHQ666.com/tags/C语言/"},{"name":"内存管理","slug":"内存管理","permalink":"http://YangHQ666.com/tags/内存管理/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://YangHQ666.com/tags/Objective-C/"}]},{"title":"C语言结构体，联合体，枚举","slug":"C语言结构体，联合体，枚举","date":"2017-10-30T13:14:15.000Z","updated":"2017-10-30T13:50:49.000Z","comments":true,"path":"2017/10/30/C语言结构体，联合体，枚举/","link":"","permalink":"http://YangHQ666.com/2017/10/30/C语言结构体，联合体，枚举/","excerpt":"","text":"C语言结构体，联合体，枚举 由于之前不怎么用，即使学过之后也忘记得很快，今天特地来重新看一下 结构体结构体之前用的次数也不算少，但是还是打算系统的再看一遍 C语言中可以使用结构体来存放一组不同类型的数据，结构体是这样定义的： 123struct 结构体名字&#123;结构体包含的变量或数组；&#125;; 其实结构体是一种数据类型，结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。比如： 123456struct Person&#123;char *name;int num;int age;float score;&#125;; //这里的分号要记得打上 这个表示Person这个结构体包含了5个成员，结构体内定义方式和变量方式的定义相同，只是结构体内的变量不能初始化。 结构体变量既然结构体是一种数据类型，那么就可以用它来定义变量。例如： 1struct Person per1,per2; 定义了两个变量per1和per2，它们都是Person类型 结构体的大小（new）观察下面例子 123456789101112131415161718struct Person&#123;char job;int pig;char dog;&#125;one; //结构体一struct Person2&#123;char job;char dog;int pig;&#125;tow;//结构体二//结构体一和结构体二中的变量类型完全相同int main()&#123;printf(&quot;one is %lu \\n&quot;,sizeof(one));printf(&quot;tow is %lu \\n&quot;,sizeof(tow));return 0; 输出结果是一样的吗？ 先介绍一个概念：偏移量——偏移量指的是结构体变量中成员的地址和结构体变量地址 的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。比如： one里面的第一个成员的偏移量为0（char类型），第二个成员的偏移量是第一个成员的偏移量加上第一个成员的大小1+0= 1（int），第三个成员的偏移量是第二个成员的偏移量加上第二个成员的大小1+4 = 5（char）； 实际上，由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：一、结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 二、结构体大小必须是所有成员大小的整数倍。 第一个成员满足要求，第二个成员的大小并不是自身的整数倍，所以编译器会在第二个成员后面补上3个空字节，此时第二个成员的偏移量为4，第三个成员的偏移量为8，由定义，one的大小为8+1 = 9；但是one此时的大小并不满足是所有成员大小的整数倍，所以最终还要再补3个字节，为12； 同理，tow里面第一个成员的偏移量是0，第二个成员的偏移量为1+0 = 1，第三个成员的偏移量为1 + 1 = 2；显然第三个成员不是它本身的整数倍，补2个0，所以第三个的偏移量为4，结构体大小为4 + 4 = 8。 结构体成员的获取和赋值当结构体为变量时候，一般格式： 结构体变量名.成员名 当结构体为指针时候 结构体变量名-&gt;成员名 = (*pointer).memberName ​ -&gt;是(*pointer)的简写 联合体（Union）定义格式123union 联合体名&#123;成员列表&#125;; 共用体和结构体之间的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。 原因：结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 比如： 12345union data&#123;int n;char ch;double f;&#125; a, b, c; 共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、b、c）也占用 8 个字节的内存 printf(&quot;%d\\n&quot;,sizeof(a)); 输出为8； 测试： 12345678910111213141516#include&lt;stdio.h&gt;union var&#123;long j;int i;&#125;;main()&#123;union var v;v.j = 5;printf(&quot;v.j is %d\\n&quot;,v.i);v.i = 6; //最后一次赋值有效printf(&quot;now v.j is %ld! the address is %p\\n&quot;,v.j,&amp;v.j);printf(&quot;now v.i is %d! the address is %p\\n&quot;,v.i,&amp;v.i);system(&quot;pause&quot;);&#125; 输出： 123v.j is 5now v.j is 6! the address is 0xbfad1e2cnow v.i is 6! the address is 0xbfad1e2c 枚举（enum）枚举的概念枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。 枚举的用法123enum 标识符&#123;枚举数据表&#125;; 例1： 12345enum status&#123;copy，delete&#125;； 枚举类型status仅有两个数据，一个是copy，一个是delete，序号为0、1，代表复制与删除。 例2: 12345enum status&#123;copy=6，delete&#125;； 则copy的序号为6，delete的序号为7。(元素与元素间用逗号隔开) 操作： 12345enum Season &#123;spring, summer, autumn, winter&#125; s;s = spring; // 等价于 s = 0;s = 3; // 等价于 s = winter; (完)","categories":[{"name":"C语言","slug":"C语言","permalink":"http://YangHQ666.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://YangHQ666.com/tags/C语言/"},{"name":"数据结构","slug":"数据结构","permalink":"http://YangHQ666.com/tags/数据结构/"},{"name":"C语言基础","slug":"C语言基础","permalink":"http://YangHQ666.com/tags/C语言基础/"}]},{"title":"几个模糊知识点的重学和回顾（一）","slug":"几个模糊知识点的重学和回顾（一）","date":"2017-10-14T05:15:39.000Z","updated":"2017-10-14T05:27:35.000Z","comments":true,"path":"2017/10/14/几个模糊知识点的重学和回顾（一）/","link":"","permalink":"http://YangHQ666.com/2017/10/14/几个模糊知识点的重学和回顾（一）/","excerpt":"","text":"几个模糊知识点的重学和回顾（一）OC中关于id和instancetype的区别 相同点： id和instancetype都可以作为方法的返回值。 不同点： id可以用来定义变量，可以作为返回值类型，可以作为形参类型；instancetype只能作为返回值类型 。 instancetype 可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象。例如：(id类型时候) 1234567891011@interface NSArray+(id)constructAnArray;@end当我们初始化的时候[NSArray constructAnArray]得到返回类型和方法声明的返回类型一样，是id （instancetype的时候） 12345678910111213如果使用 instancetype 作为返回类型@interface NSArray+(instancetype)constructAnArray;@end同样方式初始化[NSArray constructAnArray]得到的返回类型和方法所在类型相同，是 NSArray * 以后凡是自定义构造方法，返回值类型尽量使用instancetype，不要使用id 。 OC中的深拷贝和浅拷贝浅拷贝简单点说浅拷贝就是对内存地址的复制，让目标对象指针和源对象指针指向同一片内存空间。如： 12char *str = (char *)malloc(100);char *str2 = str; 深拷贝深拷贝就是拷贝地址中的内容，让目标对象产生新的内存区域，且将源内存区域中的内容复制到目标内存区域中 123456char *str = (char *)malloc(20);strcpy(str, &quot;hello world&quot;);//复制char *str2 = (char *)malloc(20);strcpy(str2, str); 深拷贝就是产生一个新的对象，将源对象的所有内容拷贝到新的对象中，新对象和源对象各自指向自己的内存区域，相互之间不受影响。 这里有一篇讲的比较好的博客 OC中的strong和weak修饰符的使用strong和weak修饰符的简单理解：​ 首先一个对象可以有多个拥有者，即A和B两个strong的指针同时指向一个NSString的对象“hello”，当A和B两个strong的指针同时指向一个NSString的对象“hello”，当A指向另一个NSString对象“hi”时，此时B仍指向“hello”，当B也指向“hi”或其他任何一个对象时，“hello”这个对象就会在内存中被删除。 ​ 如果B是一个weak类型的指针，则当strong类型的A指针指向其他对象时，因为B是一个weak类型的指针，此时B没有指向。​ 总结：一旦最后一个指向该对象的strong类型的指针离开，这个对象将被释放，如果这个时候还有weak指针指向该对象，则会清除掉所有剩余的weak指针 对于weak指针的理解：​ weak指针主要用于“父-子”关系，父亲拥有一个儿子的strong指针，因此父亲是儿子的所有者；但为了阻止所有权循环,儿子需要使用weak指针指向父亲 ​ 典型例子是delegate模式,你的ViewController通过strong指针（self.view）拥有一个UITableView, UITableView的dataSource和delegate都是weak指针,指向你的ViewController 弱指针Weak:​ 在使用 sb 或者 xib 给控件拖线的时候,为什么拖出来的先属性都是用 weak 修饰呢?​ eg 1@property (weak, nonatomic) IBOutlet UILabel *label; ​ 原因是由于在向 xib 或者 sb 里面添加控件的时候,添加的子视图是添加到了跟视图 View 上面, 而 控制器 Controller 对其根视图 View 默认是强引用的,当我们的子控件添加到 view 上面的时候, self.view addSubView: 这个方法会对添加的控件进行强引用,如果在用 strong 对添加的子控件进行修饰的话,相当于有两条强指针对子控件进行强引用, 为了避免这种情况,所以用 weak 修饰. 注意: ​ 1. addSubView 默认对其 subView 进行了强引用​ 2.在纯手码实现界面布局时，如果通过懒加载处理界面控件，需要使用strong强指针​ 除此之外,我们在开发的时候用的代理 也是用 weak 进行修饰的,其目的是为了防止控件的循环引用.​​ @property (nonatomic, weak) id delegate;","categories":[{"name":"Objective-C基础","slug":"Objective-C基础","permalink":"http://YangHQ666.com/categories/Objective-C基础/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://YangHQ666.com/tags/iOS开发/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://YangHQ666.com/tags/Objective-C/"},{"name":"iOS基础","slug":"iOS基础","permalink":"http://YangHQ666.com/tags/iOS基础/"}]},{"title":"字符搜素算法之KMP","slug":"字符串搜素算法","date":"2017-10-11T12:58:51.000Z","updated":"2017-11-11T11:40:47.000Z","comments":true,"path":"2017/10/11/字符串搜素算法/","link":"","permalink":"http://YangHQ666.com/2017/10/11/字符串搜素算法/","excerpt":"","text":"字符串搜索算法今天上数据结构只讲了搜索算法的最基本的一种，并且较优化的搜索算法也没怎么讲，来此研究一番。 kmp算法kmp算法简介KMP算法是一种改进的字符串匹配算法，KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。​ kmp算法理解 一般匹配字符串时，我们从目标字符串str（假设长度为n）的第一个下标选取和ptr长度（长度为m）一样的子字符串进行比较，如果一样，就返回开始处的下标值，不一样，选取str下一个下标，同样选取长度为n的字符串进行比较，直到str的末尾（实际比较时，下标移动到n-m）。这样的时间复杂度是O(n*m)。 在此之前先推荐一篇文章阮一峰讲解的KMP 看完推荐的blog，他提到一个公式： 1移动位数 = 已匹配的字符数 - 对应的部分匹配值 关于对应的部分匹配值，首先还是先要了解一下什么是前缀和后缀，我也引用他举的例子 字符串 ： “bread” 前缀 ：b，br，bre，brea 后缀：read，ead，ad，d 因此 最长前缀：是说以第一个字符开始，但是不包含最后一个字符。比如： abcjkdabc，那么这个数组的最长前缀和最长后缀相同必然是abc。 cbcbc，最长前缀和最长后缀相同是cbc。 abcbc，最长前缀和最长后缀相同是不存在的。 ​ 了解这些以后，我们在来说公式当中的 对应的部分匹配值 ； 部分匹配值为“最长前缀”和“最长后缀”的共有元素的长度 例如： 搜索词为：ababaca，其中从左到右数的第三个a的部分匹配值为：3；因为它的最长前缀是abab，最长后缀也是baba；所以共有的是aba。 ​ 实例应用给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。 如下面两个字符串： 12char *str = &quot;bacbababadababacambabacaddababacasdsd&quot;;char *ptr = &quot;ababaca&quot;; 第一次： bacbababadababacambabacaddababacasdsd ababaca a和b不相等，跳到下一个字符，运行2次后发现第三个不相等……..直到出现下面情况时： bacbababadababacambabacaddababacasdsd&emsp; &emsp; ababaca 这时候比较到ptr的第6个元素与str不相等时，程序进行下一次移位，但这次移位就要根据公示来移动： 移动位数 = 已匹配的字符数 - 对应的部分匹配值 ​ 5 （ababa） - 3（aba） =2位；所以下一次移位： bacbababadababacambabacaddababacasdsd&emsp; &emsp; &emsp; &emsp; ababaca； 对公式的理解其实从实例来看，之所以要减去对应的部分匹配值，是减去了前缀和后缀所重复的部分，在目标字符串str与子字符串ptr有相同部分的情况下，（1个相同而其他不同的直接转到下一个字符），在相同部分中减去了前缀和后缀所重复的部分，这样程序就可以跳过那些确定不能匹配的字符，从而减小时间复杂度（最后附上一张图） （如果1=2=3=4，就直接把3移到4的位置 ：） （完）","categories":[{"name":"算法","slug":"算法","permalink":"http://YangHQ666.com/categories/算法/"}],"tags":[{"name":"搜索算法","slug":"搜索算法","permalink":"http://YangHQ666.com/tags/搜索算法/"}]},{"title":"UItableView使用方法","slug":"UItableView使用方法","date":"2017-10-08T05:28:38.000Z","updated":"2017-10-12T06:24:54.000Z","comments":true,"path":"2017/10/08/UItableView使用方法/","link":"","permalink":"http://YangHQ666.com/2017/10/08/UItableView使用方法/","excerpt":"","text":"UItableView使用方法​ 今天写代码刚好写了下UItableView，写起来也觉得不怎么难，记录一下经常会使用到的几个功能吧！ UItableView的初始化和其他控件一样，UItableView的初始化也是一样的UITableView *settable = [[UITableView alloc]initWithFrame:CGRectMake(0, 0, 375, 667) style:UITableViewStyleGrouped];后面的style——如果你想有分组型的，就用Grouped，如果不想分组，那就选择Plain，之后要设置代理，如果你只设置了一个代理，那么写一个就行了settable.dataSource = self; settable.delegate =self;（记得要在interface后面添加协议）。 UItableView的方法当你写了&lt;UITableViewDataSource&gt;这个协议时候，会出现2个警告，因为这个协议中有2个必须要求执行的方法： 1234567@required- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; 不过先不着急实现这两个方法，先设置一下有多少组： 123- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return 3;&#125; //我这里写的是三组 之后在去写那两个要求的方法： 12345678910111213141516- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; NSInteger row = 0; if (section == 0) &#123; row = 1; &#125;else if (section == 1)&#123; row = 2; &#125;else &#123; row = 3; &#125; return row;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //这里一一给cell设置标题和各种属性，这里就不详细叙述 return cell; &#125; TableView的基本属性设置1234567//去掉 cell 上的线 myTableView.separatorStyle = UITableViewCellSeparatorStyleNone;//多余的cell不显示self.myTableView.tableFooterView = [UIView new];//取消cell点击 self.myTableView.allowsSelection = NO; Cell的属性设置和方法1234567891011121314151617181920212223242526// cell 的行高- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return 100;&#125;// 选中 cell的 触发方法- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;// NSLog(@&quot; 我被选中了 %ld, %ld&quot;, indexPath.section, indexPath.row);// 选中时有置灰效果,离开时 选中效果 消失 [tableView deselectRowAtIndexPath:indexPath animated:YES]; //取消cell的点击事件 if (2 == indexPath.row) &#123; //取消某行cell点击事件 Cell.selectionStyle = UITableViewCellSelectionStyleNone; return nightCell; &#125; // 跳转 界面// CellViewController *cellView = [[CellViewController alloc]init];// NSString *str = [NSString stringWithFormat:@&quot;%ld , %ld&quot;, indexPath.section, indexPath.row];// cellView.string =str;// [self.navigationController pushViewController:cellView animated:YES];//给cell设置图片cell.imageView.image = [UIImage imageNamed:@&quot;add&quot;]; 在代码中点击cell后出现提示框（即UIAlert），我是用条件控制的：(以其中任意一个按钮为例) 1234if (indexPath.section == 2 &amp;&amp; indexPath.row == 2) &#123; UIAlertController *alert1 = [UIAlertController alertControllerWithTitle:@&quot;更新完成&quot; message:@&quot;现在已经是最新版本&quot; preferredStyle:UIAlertControllerStyleAlert]; [alert1 addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleCancel handler:nil]]; [self presentViewController:alert1 animated:YES completion:nil]; UItableView基本上用到的属性和方法差不多也就这些了，欢迎大家补充。 （完）","categories":[{"name":"UI设计","slug":"UI设计","permalink":"http://YangHQ666.com/categories/UI设计/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://YangHQ666.com/tags/iOS开发/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://YangHQ666.com/tags/Objective-C/"}]},{"title":"音乐调性","slug":"音乐调性","date":"2017-10-08T05:28:38.000Z","updated":"2017-10-12T06:24:18.000Z","comments":true,"path":"2017/10/08/音乐调性/","link":"","permalink":"http://YangHQ666.com/2017/10/08/音乐调性/","excerpt":"","text":"我们生活中经常会听说这首歌是什么C调什么D调，你知道调是怎么规定的吗？ 基本概念调性（Tonality）是调的主音和调式类别的总称，例如，以C为主音的大调式，其调性即是“C大调”，以a为主音的小调式，其调性就是“a小调”等。以此类推，一般音乐中主要有24个调性。首先就拿大家比较熟悉的C大调开始说起。 关于C大调不同音之间是有距离的，十二平均律将一个八度音程（12345671）分为12等份，每等份称为一个半音，两个半音距离构成一个全音。在一个标准音阶中，除了3-4、7-1之间是半音的距离，其他的相邻两个音之间都是全音的距离。也就是说，他们之间还存在着一个半音距离的音符（如1-2之间有一个1#=2b），加上1#、2#、4#、5#、6#，正好为12等份（不包含最后一个Do），如下图所示。而C大调音阶，就是以C音为1，CDEFGAB的相邻音符距离恰恰和标准音阶1234567的距离一致（全全半全全全半，不用升降号）。因此，C大调是最自然的大调，也是最基础的调。 唱名和音名 唱名：1234567，在简谱首调中出现，没有绝对音高，多用于流行乐。任何人可以根据自己适应的音域从任意高度起唱1（do）。比如男生和女生唱同一段旋律，男生音高一般低于女生，但是由于音符之间的距离相同，我们知道他们唱的是同一首歌曲，可以用同一段简谱记录。 音名：CDEFGAB，指的是五线谱中固定调的绝对音高，多用于古典乐。比如标准音A，其频率为440Hz，音高是固定的，国际公认。交响乐团就是以绝对音高的方式，使得不同乐器能够协调统一。 由于唱名是不固定的，将唱名和固定音高建立起确定的关系，就产生了调。如以C音高度为起音1（do），就称为C大调，G=1，就是G大调。（这里科普一下C的标准音：每秒振动约261次的c音在乐音体系中叫中央c，它位于基本音级首位） 大调和小调之所以要区分大小调，从感官上来讲，是因为乐曲的调式色彩不同。大调一般明朗开阔，小调一般柔和暗淡。那么为什么会产生这种听觉效果呢？源于它们具有不同的音阶结构。大调：1 2 3-4 5 6 7-1全 全 半 全 全 全 半小调：6 7-1 2 3-4 5 6全 半 全 全 半 全 全要满足小调的音程关系，则用首调听起来，小调的起因就是6（la）。因此，D小调就可以简单理解为：以D音为6（la）的调。 怎样判断一首歌是什么调呢？在我们理解上面的概念以后，简而言之判断调性就是：do到底定多高”这么个问题。决定一个有人声的歌曲的调性，肯定是以人声的音域为主要参考，所有乐器都应该是为人生服务的。乐器的音高系统会有影响，比如有首歌依照人声，我想定1=bB，但是伴奏有样乐器是C大调的，演奏不了bB这种音。那么看看人声能不能在1=C时候演唱好这首歌，能行就定成1=C，如果不行那咱们就换个乐器。至于曲风，可能影响比较小吧。可能有的曲风需要旋律线大起大落，音域宽阔，有的曲风旋律线可能比较平直。但我想来这跟定调没有太大的关系吧。（来自知乎大神的解答） 最后，还有一点：多听，多想 （完）","categories":[{"name":"音乐","slug":"音乐","permalink":"http://YangHQ666.com/categories/音乐/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://YangHQ666.com/tags/音乐/"},{"name":"乐理","slug":"乐理","permalink":"http://YangHQ666.com/tags/乐理/"}]},{"title":"YHQ","slug":"YHQ","date":"2017-10-06T07:41:27.000Z","updated":"2017-10-06T07:55:54.000Z","comments":true,"path":"2017/10/06/YHQ/","link":"","permalink":"http://YangHQ666.com/2017/10/06/YHQ/","excerpt":"","text":"","categories":[],"tags":[{"name":"你好，欢迎来到我的blog，这里应有尽有","slug":"你好，欢迎来到我的blog，这里应有尽有","permalink":"http://YangHQ666.com/tags/你好，欢迎来到我的blog，这里应有尽有/"}]}]}